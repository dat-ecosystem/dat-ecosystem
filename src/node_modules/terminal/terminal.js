const tab_window = require('tab-window')
const tab_button = require('buttons/tab-button')
const sm_icon_button_alt = require('buttons/sm-icon-button-alt')
const scrollbar = require('scrollbar')
/******************************************************************************
  TERMINAL COMPONENT
******************************************************************************/
// ----------------------------------------
// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
// ----------------------------------------
const sheet = new CSSStyleSheet
sheet.replaceSync(get_theme())
const default_opts = { }
const shopts = { mode: 'closed' }
// ----------------------------------------
module.exports = terminal
// ----------------------------------------
function terminal (opts = default_opts, protocol) {
  // ----------------------------------------
  // RESOURCE POOL (can't be serialized)
  // ----------------------------------------
  const viewports = {}
  const _ = { viewports }
  const ro = new ResizeObserver(entries => {
    console.log('ResizeObserver:terminal:resize')
    const scroll_channel = state.net[state.aka.scrollbar]
    scroll_channel.send({
      head: [id, scroll_channel.send.id, scroll_channel.mid++],
      refs: { },
      type: 'handle_scroll',
    })
    //Added this to avoid a very sticky situation where the height of tabs_window needs to be changed when scrollbar appear
    if(scrollbar_wrapper.clientHeight !== status.scrollbar_height){
      status.scrollbar_height = scrollbar_wrapper.clientHeight
      if(scrollbar_wrapper.clientHeight > 0)
        for(let i = 0; i < status.tab_id; i++){
          const channel = state.net[state.aka[`win-tab-${i}`]]
          channel.send({
            head: [id, scroll_channel.send.id, scroll_channel.mid++],
            type: 'shrink'
          })
        }
      else
        for(let i = 0; i < status.tab_id; i++){
          const channel = state.net[state.aka[`win-tab-${i}`]]
          channel.send({
            head: [id, scroll_channel.send.id, scroll_channel.mid++],
            type: 'stretch'
          })
        }
    }
  })
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const status = { active_tab: null, tab_id: 1, tab: {}, scrollbar_height: 0 }
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {} } // all state of component instance
  const cache = resources({})
  // ----------------------------------------
  // OPTS
  // ----------------------------------------
  const {
    icon_terminal,
    icon_close_light,
    icon_plus,
    icon_full_screen
  } = opts.data.img_src
  // ----------------------------------------
  // PROTOCOL
  // ----------------------------------------
  const on = {}
  const channel = use_protocol('up')({ protocol, state, on })
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div')
  const shadow = el.attachShadow(shopts)
  shadow.adoptedStyleSheets = [sheet]
  shadow.innerHTML = `<div class="terminal_wrapper">
    <div class="terminal">
      <div class="header">${icon_terminal}Terminal</div>
      <div class="tab_display"></div>
      <div class="footer">
        <div class="tabs_bar">
          <div class="tab_buttons"></div>
        </div>
        <div class="buttons"></div>
      </div>
      <div class="scrollbar_wrapper"></div>
    </div>
  </div>`
  const terminal_wrapper = shadow.querySelector('.terminal')
  const tab_buttons = shadow.querySelector('.tab_buttons')
  const tabs_bar = shadow.querySelector('.tabs_bar')
  // ----------------------------------------
  const tab_buttons_shadow = tab_buttons.attachShadow(shopts)
  const tab_display = shadow.querySelector('.tab_display').attachShadow(shopts)
  const scrollbar_wrapper = shadow.querySelector('.scrollbar_wrapper')
  const buttons = shadow.querySelector('.buttons').attachShadow(shopts)
  // ----------------------------------------
  // ELEMENTS
  // ----------------------------------------
  { // plus button
    const on = { 'click': on_spawn }
    const protocol = use_protocol('plus_button')({ state, on })
    const opts = { src: icon_plus }
    const element = shadowfy()(sm_icon_button_alt(opts, protocol))
    buttons.append(element)
    function on_spawn (message) { add_tab('tab-' + state.status.tab_id++) }
  }
  { // fullscreen button
    if (screen.width > 510) {
      const on = { 'click': on_fullscreen }
      const protocol = use_protocol('fullscreen')({ state, on })
      const opts = { src: icon_full_screen }
      const element = shadowfy()(sm_icon_button_alt(opts, protocol))
      buttons.append(element)
      status.fullscreen = terminal_wrapper.style.height === '100vh'
      function on_fullscreen (message) {
        const ismax = status.fullscreen
        terminal_wrapper.style.height = ismax ? '100%' : '100vh'
        terminal_wrapper.style.width = '100%'
        terminal_wrapper.style.position = 'absolute'
        terminal_wrapper.style.bottom = 0
        status.fullscreen = !ismax
        Object.keys(state.aka).forEach(x => {
          if(x.includes('win')){
            const channel = state.net[state.aka[x]]
            channel.send({
              head: [id, channel.send.id, channel.mid++],
              type: 'toggle_fullscreen'
            })
          }
        })
      }
    }
  }
  { // close button
    const on = { 'click': on_close }
    const protocol = use_protocol('close_button')({ state, on })
    const opts = { src: icon_close_light }
    const element = shadowfy()(sm_icon_button_alt(opts, protocol))
    buttons.append(element)
    function on_close (message) {
      const up_channel = state.net[state.aka.up]
      up_channel.send({
        head: [id, up_channel.send.id, up_channel.mid++],
        refs: { cause: message.head },
        type: 'toggle_terminal',
      })
    }
  }
  { // scrollbar
    const on = { 'set_scroll': on_set_scroll, 'status': on_update_size }
    const protocol = use_protocol('scrollbar')({ state, on })
    opts.horizontal = true
    opts.data.img_src.icon_arrow_start = opts.data.img_src.icon_arrow_left
    opts.data.img_src.icon_arrow_end = opts.data.img_src.icon_arrow_right
    const scroll_opts = opts
    const element = scrollbar(scroll_opts, protocol)

    tab_buttons.onscroll = on_scroll
    const scroll_channel = state.net[state.aka.scrollbar]
    ro.observe(tab_buttons)

    scrollbar_wrapper.append(element)

    function on_scroll (event) {
      console.log('tab_buttons:terminal:scroll')
      scroll_channel.send({
        head: [id, scroll_channel.send.id, scroll_channel.mid++],
        refs: { },
        type: 'handle_scroll',
      })
    }
    function on_set_scroll (message) {
      console.log('set_scroll', message) 
      setScrollLeft(message.data)
    }
    function on_update_size (message) {
      const head = [id, scroll_channel.send.id, scroll_channel.mid++]
      scroll_channel.send({
        head,
        refs: { cause: message.head },
        type: 'update_size',
        data: {
          sh: tab_buttons.scrollWidth,
          ch: tab_buttons.clientWidth,
          st: tab_buttons.scrollLeft
        }
      })
    }
    async function setScrollLeft (value) {
      tab_buttons.scrollLeft = value
    }
  }
  // ----------------------------------------
  // INIT
  // ----------------------------------------
  add_tab('tab-0')

  return el

  function add_tab (label) {
    const petname_win = `win-${label}`
    const petname_btn = `btn-${label}`
    { // tab button
      const on = { 'close': close_tab, 'click': switch_tab }
      const protocol = use_protocol(petname_btn)({ state, on })
      const btn_opts = { data: opts.data, name: label }
      const element = tab_button(btn_opts, protocol)
      tab_buttons_shadow.append(element)

      state.status.tab[petname_btn] = state.aka[petname_btn]

      if (Object.keys(viewports).length < 1) ro.observe(tab_buttons)

      if (state.status.active_tab) {
        const active_channel = state.net[state.status.active_tab]
        active_channel.send({
          head: [id, active_channel.send.id, active_channel.mid++],
          type: 'inactivate'
        })
        const scroll_channel = state.net[state.aka.scrollbar]
        const head = [id, scroll_channel.send.id, scroll_channel.mid++]
        scroll_channel.send({ head, type: 'handle_scroll' })
      }
    }
    { // tab window
      const on = {
        'navigate': on_navigate
      }
      const protocol = use_protocol(petname_win)({ state, on })
      const win_opts = { data: opts.data, text: label }
      const element = tab_window(win_opts, protocol)
      tab_display.replaceChildren(element)

      const tab_id = state.status.tab[petname_btn]
      _.viewports[tab_id] = element
      state.status.active_tab = tab_id
      function on_navigate ({ data }){
        const up_channel = state.net[state.aka.up]
        up_channel.send({
          head: [id, up_channel.send.id, up_channel.mid++],
          type: 'navigate',
          data
        })
      }
    }

    async function switch_tab () {
      const btn_id = state.status.tab[petname_btn]
      if (state.status.active_tab === btn_id) return
      const active_channel = state.net[state.status.active_tab]
      active_channel.send({
        head: [id, active_channel.send.id, active_channel.mid++],
        type: 'inactivate'
      })
      state.status.active_tab = btn_id // set tab as active one
      const channel = state.net[btn_id]
      channel.send({
        head: [id, channel.send.id, channel.mid++],
        type: 'activate'
      })
      tab_display.replaceChildren(viewports[btn_id])
    }
    async function close_tab (message) {
      const tab_id = state.status.tab[petname_btn]
      if (Object.keys(viewports).length > 1) {
        if (state.status.active_tab === tab_id) {
          const ids = Object.values(status.tab)
          const next_id = ids[(ids.indexOf(tab_id) || ids.length) - 1]
          state.status.active_tab = next_id
          const btn_channel = state.net[next_id]
          btn_channel.send({
            head: [id, btn_channel.send.id, btn_channel.mid++],
            type: 'activate'
          })
          const next_tab_win = viewports[next_id]
          tab_display.replaceChildren(next_tab_win)
        }
      } else {
        state.status.active_tab = undefined
        tab_display.replaceChildren()
        ro.unobserve(tab_buttons)
        return cleanup()
      }
      cleanup()
      const scroll_channel = state.net[state.aka.scrollbar]
      const head = [id, scroll_channel.send.id, scroll_channel.mid++]
      scroll_channel.send({ head, refs: { cause: message.head }, type: 'handle_scroll' })
      function cleanup () {
        delete viewports[tab_id]
        const { petname } = state.net[tab_id]
        delete state.net[tab_id]
        delete state.status.tab[petname]
        delete state.aka[petname]  
      }
    }
  }
}
function get_theme () {
  return `
    :host {
      height: 100%;
    }
    * {
      box-sizing: border-box;
    }
    .terminal_wrapper {
      display: flex;
      flex-direction: column;
      container-type: inline-size;
      width: 100%;
      height: 100%;
      min-height: 300px;
    }
    
    .terminal_wrapper .terminal {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      background-color: var(--bg_color);
    }
    .terminal .header {
      display: flex;
      background-color: var(--primary_color);
      color: var(--bg_color);
      padding: 10px 5px;
      align-items: center;
      gap: 5px;
    }
    .terminal .header svg path {
      fill: white;
    }
    .tab_display {
      background-color: var(--bg_color);
      border: 5px solid var(--primary_color);
      flex-grow: 1;
    }
    .footer {
      width: 100%;
      max-width: 100%;
      --s: 20px; /* control the size */
      --_g: var(--bg_color) /* first color */ 0 25%, #0000 0 50%;
      background:
        repeating-conic-gradient(at 66% 66%,var(--_g)),
        repeating-conic-gradient(at 33% 33%,var(--_g)),
        var(--primary_color);  /* second color */ 
      background-size: var(--s) var(--s);
      display: flex;
      justify-content: space-between;
    }
    .footer .tabs_bar {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .tabs_bar .tab_buttons {
      display: flex;
      overflow-x: scroll;
      scrollbar-width: none; /* For Firefox */
    }
    .tabs_bar .tab_buttons::-webkit-scrollbar {
      display: none;
    }
    .footer .buttons {
      display: flex;
      widht: fit-content;
    }
    .footer .buttons div {
      height: fit-content;
    }
    @container (min-width: 510px) {
      .terminal {
        height: 100%;
      }
    }
  `
}
// ----------------------------------------------------------------------------
function shadowfy (props = {}, sheets = []) {
  return element => {
    const el = Object.assign(document.createElement('div'), { ...props })
    const sh = el.attachShadow(shopts)
    sh.adoptedStyleSheets = sheets
    sh.append(element)
    return el
  }
}
function use_protocol (petname) {
  return ({ protocol, state, on = { } }) => {
    if (petname in state.aka) throw new Error('petname already initialized')
    const { id } = state
    const invalid = on[''] || (message => console.error('invalid type', message))
    if (protocol) return handshake(protocol(Object.assign(listen, { id })))
    else return handshake
    // ----------------------------------------
    // @TODO: how to disconnect channel
    // ----------------------------------------
    function handshake (send) {
      state.aka[petname] = send.id
      const channel = state.net[send.id] = { petname, mid: 0, send, on }
      return protocol ? channel : Object.assign(listen, { id })
    }
    function listen (message) {
      const [from] = message.head
      const by = state.aka[petname]
      if (from !== by) return invalid(message) // @TODO: maybe forward
      console.log(`[${id}]:${petname}>`, message)
      const { on } = state.net[by]
      const action = on[message.type] || invalid
      action(message)
    }
  }
}
// ----------------------------------------------------------------------------
function resources (pool) {
  var num = 0
  return factory => {
    const prefix = num++
    const get = name => {
      const id = prefix + name
      if (pool[id]) return pool[id]
      const type = factory[name]
      return pool[id] = type()
    }
    return Object.assign(get, factory)
  }
}